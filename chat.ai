## SYSTEM:

These are my files:

docker-compose.yaml:
<ai-context>/Users/andreas/r8/img-quality-eval/docker-compose.yaml</ai-context>

Dockerfile:
<ai-context>/Users/andreas/r8/img-quality-eval/Dockerfile</ai-context>

requirements.txt:
<ai-context>/Users/andreas/r8/img-quality-eval/requirements.txt</ai-context>

img_quality_eval/settings.py:
<ai-context>/Users/andreas/r8/img-quality-eval/img_quality_eval/settings.py</ai-context>

app/tasks.py:
<ai-context>/Users/andreas/r8/img-quality-eval/app/tasks.py</ai-context>

app/static/js/results.js:
<ai-context>/Users/andreas/r8/img-quality-eval/app/static/js/results.js</ai-context>

app/static/js/index.js:
<ai-context>/Users/andreas/r8/img-quality-eval/app/static/js/index.js</ai-context>

app/static/js/data_form.js:
<ai-context>/Users/andreas/r8/img-quality-eval/app/static/js/data_form.js</ai-context>

app/templates/results.html:
<ai-context>/Users/andreas/r8/img-quality-eval/app/templates/results.html</ai-context>

app/templates/index.html:
<ai-context>/Users/andreas/r8/img-quality-eval/app/templates/index.html</ai-context>

app/templates/data_form.html:
<ai-context>/Users/andreas/r8/img-quality-eval/app/templates/data_form.html</ai-context>

img_quality_eval/urls.py:
<ai-context>/Users/andreas/r8/img-quality-eval/img_quality_eval/urls.py</ai-context>

app/models.py:
<ai-context>/Users/andreas/r8/img-quality-eval/app/models.py</ai-context>

app/views.py:
<ai-context>/Users/andreas/r8/img-quality-eval/app/views.py</ai-context>

app/urls.py:
<ai-context>/Users/andreas/r8/img-quality-eval/app/urls.py</ai-context>

app/data.py:
<ai-context>/Users/andreas/r8/img-quality-eval/app/data.py</ai-context>

img_quality_eval/celery.py:
<ai-context>/Users/andreas/r8/img-quality-eval/img_quality_eval/celery.py</ai-context>


---

This is the instructions for the app:

<ai-context>/Users/andreas/r8/img-quality-eval/prompt.txt</ai-context>

## USER:

Implement duck_type

## ASSISTANT:

Certainly! Here's an implementation of the `duck_type` function that you can add to your `app/views.py` file:

```python
def duck_type(inputs: dict[str, str]) -> dict[str, str | int | float | bool]:
    def try_convert(value: str) -> str | int | float | bool:
        # Try to convert to bool
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'

        # Try to convert to int
        try:
            return int(value)
        except ValueError:
            pass

        # Try to convert to float
        try:
            return float(value)
        except ValueError:
            pass

        # If all else fails, return the original string
        return value

    return {key: try_convert(value) for key, value in inputs.items()}
```

This `duck_type` function takes a dictionary with string keys and string values, and attempts to convert each value to the most appropriate type (boolean, integer, float, or string). Here's how it works:

1. We define an inner function `try_convert` that attempts to convert a single string value to the most appropriate type.

2. For each value, it first checks if it's a boolean ("true" or "false", case-insensitive).

3. If it's not a boolean, it tries to convert to an integer.

4. If that fails, it tries to convert to a float.

5. If all conversions fail, it leaves the value as a string.

6. The main function uses a dictionary comprehension to apply `try_convert` to all values in the input dictionary.

This implementation will convert values as follows:

- "true" or "false" (case-insensitive) to `True` or `False`
- "123" to the integer `123`
- "3.14" to the float `3.14`
- Any other string will remain a string

You can add this function to your `app/views.py` file, right after the `get_prompts` function. Make sure to import the necessary types at the top of the file:

```python
from typing import Union
```

Now you can use this `duck_type` function in your `submit_replicate_model` view to convert the input values to their appropriate types before storing them in the database.

## USER:
